# 프로젝트 상세 개요 (PROJECT_OVERVIEW)

## 1. 배경과 문제 정의

법인 차량 예약 시스템은 기업 내 차량을 효율적으로 관리하고 배정하기 위해 기획되었습니다. 기존의 수기 예약 방식이나 단순한 스프레드시트 관리의 한계를 극복하고, 다음과 같은 문제를 해결하고자 했습니다:

- **중복 예약 문제**: 동일 시간대에 같은 차량에 여러 예약이 발생하는 문제
- **예약 충돌 관리**: 예약 시간이 겹칠 때의 처리 방안 부재
- **권한 관리**: 일반 사용자와 관리자의 기능 분리 필요
- **예약 추적**: 예약 변경 이력 및 감사 로그 관리 필요
- **자동화 부재**: 반납 지연, 연장 등의 상황에 대한 자동 처리 부재

## 2. 요구사항 정의

### 기능 요구사항

#### 예약 관리
- 차량 예약 생성, 수정, 취소 기능
- 예약 시간 충돌 자동 감지 및 차단
- 예약 연장 기능 (최대 60분, 최대 2회)
- 예약 상태 관리 (RESERVED → IN_USE → COMPLETED)
- 예약 감사 로그 기록

#### 동승 시스템
- 다른 사용자 예약에 동승 요청 기능
- 동승 요청 승인/거절 처리
- 좌석 수 기반 동승 가능 여부 판단

#### 자동화 기능
- 반납 지연 시 자동 연장 (30분씩)
- 연장 시 다음 예약자에게 대체 차량 자동 제안
- 차량별 버퍼 시간 적용 (기본 20분)

#### 권한 관리
- USER: 본인 예약만 조회/수정/취소 가능
- ADMIN: 전체 예약 조회/수정/취소 가능, 사용자 관리, 대시보드 접근

### 비기능 요구사항

- **성능**: 예약 조회 시 1초 이내 응답
- **안정성**: 데이터베이스 레벨에서 중복 예약 방지 보장
- **확장성**: 멀티 테넌트 구조 고려 (현재는 단일 조직 기준)
- **보안**: 세션 기반 인증, 권한별 API 접근 제어
- **추적성**: 모든 예약 변경 사항에 대한 감사 로그 기록

## 3. 설계 상세

### 전체 흐름

#### 예약 생성 흐름
1. 사용자가 예약 요청 (차량, 시간, 목적지)
2. 시스템이 차량 사용 가능 여부 확인
3. 예약 시간 충돌 검사 (데이터베이스 제약 포함)
4. 충돌 시 대체 차량 제안 또는 에러 반환
5. 예약 생성 및 감사 로그 기록

#### 예약 연장 흐름
1. 사용자가 예약 연장 요청
2. 연장 횟수 및 한도 확인
3. 후속 예약 존재 여부 확인
4. 충돌 시 대체 차량 제안 또는 에러 반환
5. 연장 처리 및 감사 로그 기록

#### 자동 연장 흐름 (설계)
1. 스케줄러가 반납 예정 시간 확인
2. 반납 지연 감지 시 자동으로 30분 연장
3. 다음 예약자에게 알림 발송
4. 충돌 발생 시 대체 차량 제안

### 핵심 모듈/클래스 역할

#### ReservationService
- 예약 생성, 수정, 취소, 연장 로직 처리
- 예약 충돌 검사 및 대체 차량 제안
- 권한 확인 및 비즈니스 규칙 검증

#### ReservationRepository
- 예약 데이터 CRUD 작업
- 충돌 예약 조회 쿼리 (`findConflictingReservations`)
- 사용자별 예약 조회

#### Reservation 엔티티
- 예약 정보 저장 (차량 ID, 사용자 ID, 시간, 상태 등)
- 예약 상태 관리 (RESERVED, IN_USE, COMPLETED, CANCELED)
- 연장 횟수 및 한도 관리

#### 데이터베이스 제약
- `EXCLUDE USING GIST` 제약: 동일 차량의 시간 범위 겹침 방지
- 트리거: `end_with_buffer` 자동 계산
- 외래키 제약: 데이터 무결성 보장

### 입출력 구조

#### 예약 생성 요청 (CreateReservationRequest)
```json
{
  "vehicleId": 101,
  "startAt": "2024-01-15T09:00:00+09:00",
  "endAt": "2024-01-15T18:00:00+09:00",
  "destination": "강남구 테헤란로",
  "passengerCount": 2,
  "isUrgent": false,
  "note": "고객 미팅"
}
```

#### 예약 응답 (ReservationResponse)
```json
{
  "id": 1001,
  "vehicleId": 101,
  "vehicleName": "소나타",
  "plateNo": "12가3456",
  "userId": 10,
  "userName": "김철수",
  "status": "RESERVED",
  "startAt": "2024-01-15T09:00:00+09:00",
  "endAt": "2024-01-15T18:00:00+09:00",
  "destination": "강남구 테헤란로",
  "passengerCount": 2,
  "extensionCount": 0,
  "extensionLimit": 2
}
```

#### 충돌 응답 (ConflictDetails)
```json
{
  "code": "RESV_004",
  "message": "다음 예약과 충돌되어 대체차량을 제안합니다",
  "details": {
    "nextReservationId": 1102,
    "conflictTime": "2024-01-15T18:30:00+09:00"
  },
  "suggestions": [
    {
      "vehicleUnitId": 205,
      "vehicleName": "K5",
      "plateNo": "56다7890",
      "availableFrom": "2024-01-15T18:00:00+09:00"
    }
  ]
}
```

## 4. 실험 기록 및 연구한 것들

### 중복 예약 방지 실험

**목적**: 데이터베이스 레벨에서 중복 예약을 완전히 차단

**시도한 방법**:
1. 애플리케이션 레벨에서 충돌 검사 (초기 시도)
   - 문제: 동시 요청 시 Race Condition 발생 가능
   - 결과: 불완전한 해결책

2. PostgreSQL `EXCLUDE USING GIST` 제약 사용
   - `tstzrange` 타입으로 시간 범위 표현
   - GIST 인덱스로 범위 겹침 검사
   - 결과: 데이터베이스 레벨에서 완전한 중복 방지 보장

**학습한 점**:
- 데이터베이스 제약을 활용하면 애플리케이션 로직보다 더 안전하고 효율적
- `btree_gist` 확장을 통한 범위 타입 인덱싱의 강력함
- 버퍼 시간을 포함한 종료 시간 계산의 필요성

### 자동 연장 시나리오 설계

**목적**: 반납 지연 시 자동으로 처리하여 사용자 편의성 향상

**설계한 시나리오**:
1. 반납 예정 시간 경과 시 자동 감지
2. 30분씩 자동 연장 (최대 2회, 총 60분)
3. 다음 예약자에게 알림 발송
4. 충돌 발생 시 대체 차량 자동 제안

**고려사항**:
- 연장 횟수 제한으로 무한 연장 방지
- 다음 예약자와의 충돌 감지 및 처리
- 사용자에게 명확한 알림 제공

**미완성 부분**:
- 실제 스케줄러 구현은 미완성 (설계만 완료)
- WebSocket을 통한 실시간 알림 구현 필요

### 승인 흐름 기획

**목적**: 동승 요청에 대한 체계적인 승인 프로세스 설계

**설계한 워크플로우**:
1. 사용자 A가 예약 생성
2. 사용자 B가 동승 요청 (좌석 수 지정)
3. 사용자 A가 요청 확인 및 승인/거절
4. 승인 시 동승자 정보 기록

**상태 관리**:
- PENDING: 요청 대기 중
- ACCEPTED: 승인됨
- REJECTED: 거절됨
- CANCELED: 요청 취소됨

**고려사항**:
- 차량 좌석 수와 동승 요청 좌석 수 비교
- 여러 동승 요청이 있을 때의 처리 방안
- 동승 요청 취소 시 처리

### 권한 기반 기능 분리

**목적**: 사용자 역할에 따라 다른 기능과 화면 제공

**구현한 권한 체계**:
- USER: 본인 예약만 관리, 동승 요청/응답
- ADMIN: 전체 예약 관리, 사용자 관리, 대시보드 접근

**설계한 접근 제어**:
- API 레벨: Spring Security를 통한 엔드포인트별 권한 체크
- 프론트엔드: Vue Router의 네비게이션 가드 활용
- 화면 분기: 권한에 따라 다른 컴포넌트 렌더링

**학습한 점**:
- API 명세서에 권한 정보를 명시하는 것의 중요성
- 프론트엔드와 백엔드의 권한 체크를 모두 구현해야 보안 강화

### 잘 되지 않았던 시도

**초기 ERD 설계의 복잡성**:
- 처음에는 `vehicle`과 `vehicle_unit`을 분리하여 설계
- 문제: 불필요한 복잡성, 조인 쿼리 증가
- 해결: 단일 `vehicle` 테이블로 통합하여 단순화

**예약 충돌 검사 성능**:
- 초기에는 모든 예약을 조회하여 애플리케이션에서 충돌 검사
- 문제: 예약이 많아질수록 성능 저하
- 해결: 데이터베이스 인덱스와 제약을 활용하여 효율성 향상

## 5. 마무리

### 이 프로젝트에서 얻은 인사이트

**설계 우선의 중요성**:
- OpenAPI 명세를 먼저 작성함으로써 프론트엔드와 백엔드 개발자 간의 명확한 인터페이스 정의
- ERD 설계를 통해 데이터 구조를 먼저 정립하고, 이를 기반으로 비즈니스 로직 설계

**데이터베이스 제약의 활용**:
- 애플리케이션 로직만으로는 완전한 데이터 무결성 보장이 어려움
- 데이터베이스 레벨의 제약 조건을 적극 활용하면 더 안전하고 효율적인 시스템 구축 가능

**예약 시스템의 복잡성**:
- 단순해 보이는 예약 시스템도 실제로는 다양한 엣지 케이스가 존재
- 충돌 처리, 자동 연장, 권한 관리 등 다양한 시나리오를 고려한 설계 필요

### 실서비스 관점에서의 확장 가능성

**멀티 테넌트 확장**:
- 현재는 단일 조직 기준으로 설계되어 있으나, `organization` 테이블을 활용하여 멀티 테넌트 구조로 확장 가능
- 조직별 차량 관리, 예약 정책 차별화 가능

**실시간 기능 강화**:
- WebSocket을 통한 실시간 알림 구현
- 예약 상태 변경 시 실시간 업데이트
- 차량 위치 추적 기능 추가 (GPS 연동)

**분석 및 최적화**:
- 예약 패턴 분석을 통한 차량 배치 최적화
- 이용률 통계 및 예측 기능
- 사용자별 예약 패턴 분석

**모바일 앱 연동**:
- REST API를 활용한 모바일 앱 개발
- 푸시 알림 기능 추가
- 오프라인 예약 기능 (동기화)

**고급 기능**:
- 예약 대기열 시스템 (인기 차량의 경우)
- 예약 추천 시스템 (목적지 기반)
- 차량 공유 최적화 (동승 매칭 알고리즘)


