# 트러블슈팅

## 1. 예약 시간 충돌 규칙 미정

### 문제 상황
예약 시간이 겹칠 때 처리 방법이 명확하지 않아 다양한 시나리오에서 일관성 없는 동작이 발생했습니다. 단순히 에러를 반환하는 것만으로는 사용자 경험이 좋지 않았고, 어떤 경우에는 예약이 되고 어떤 경우에는 안 되는지 예측하기 어려웠습니다.

### 원인 분석
- 예약 충돌 처리에 대한 명확한 정책이 없었음
- 충돌 발생 시 사용자에게 제공할 정보가 부족함
- 다양한 예약 시나리오(긴급 예약, 자동 연장, 관리자 개입 등)를 고려하지 않음

### 해결 과정

#### 1단계: 정책 수립
다음과 같은 정책을 수립했습니다:
- **선점 정책**: 먼저 예약한 사용자가 우선권을 가짐
- **자동 연장 정책**: 반납 지연 시 30분씩 자동 연장 (최대 2회, 총 60분)
- **관리자 승인 정책**: 관리자가 충돌 상황을 판단하여 처리

#### 2단계: 우선순위 알고리즘 설계
동시 예약 시 우선순위를 결정하는 알고리즘을 설계했습니다:
1. 긴급 예약 (`is_urgent = true`)
2. 긴 예약 기간 (긴 시간 예약자가 우선)
3. 직책 순위 (`position_rank` 높은 순)

#### 3단계: 대체 차량 제안 로직 구현
충돌 발생 시 단순 에러가 아닌 대체 차량을 자동으로 검색하여 제안하도록 설계했습니다.

### 해결 결과
- 예약 충돌 시 명확한 처리 규칙 적용
- 사용자에게 대체 차량을 제안하여 즉시 재예약 가능
- 다양한 예약 시나리오에 유연하게 대응 가능

### 배운 점
- 비즈니스 로직을 명확히 정의하는 것의 중요성
- 사용자 경험을 고려한 에러 처리의 필요성
- 다양한 시나리오를 사전에 고려한 설계의 중요성

## 2. 사용자/관리자 권한이 섞여 API 복잡

### 문제 상황
초기 설계에서는 사용자와 관리자의 권한 체크가 각 엔드포인트에 산재되어 있어 API 구조가 복잡했습니다. 같은 엔드포인트에서 권한에 따라 다른 동작을 하도록 설계되어 있어 코드 가독성이 떨어지고 유지보수가 어려웠습니다.

예를 들어, `/api/reservations` 엔드포인트에서:
- USER 권한: 본인 예약만 조회
- ADMIN 권한: 전체 예약 조회

이런 식으로 권한 체크 로직이 각 엔드포인트에 포함되어 있어 복잡도가 높았습니다.

### 원인 분석
- 권한별 엔드포인트 분리가 명확하지 않음
- 권한 체크 로직이 비즈니스 로직과 섞여 있음
- API 문서에서 권한별 기능을 파악하기 어려움

### 해결 과정

#### 1단계: 네임스페이스 구조화
`/user/*`와 `/admin/*` 네임스페이스로 구조화하여 권한별 엔드포인트를 명확히 분리했습니다.

**변경 전**:
- `/api/reservations` (권한에 따라 다른 동작)
- `/api/users` (권한에 따라 다른 동작)

**변경 후**:
- `/api/user/reservations` (사용자 전용)
- `/api/admin/reservations` (관리자 전용)
- `/api/user/me` (사용자 본인 정보)
- `/api/admin/users` (관리자 전용)

#### 2단계: 권한 체크 로직 분리
권한 체크 로직을 비즈니스 로직과 분리하여 각 컨트롤러에서 명확하게 처리하도록 했습니다.

#### 3단계: API 문서 업데이트
OpenAPI 명세서에 권한별 엔드포인트를 명확히 표시하여 프론트엔드 개발자가 쉽게 이해할 수 있도록 했습니다.

### 해결 결과
- API 구조가 명확해져 프론트엔드 개발자가 쉽게 이해할 수 있음
- 권한 체크 로직이 단순해져 유지보수 용이
- API 문서에서 권한별 기능을 한눈에 파악 가능
- 코드 가독성 향상

### 배운 점
- API 설계 시 권한 관리를 처음부터 고려하는 것의 중요성
- 네임스페이스 분리를 통한 구조화의 효과
- 명확한 API 구조가 개발 효율성에 미치는 영향

## 3. UI에서 예약 판단 정보 누락

### 문제 상황
초기 UI 설계에서는 사용자가 예약 가능 여부를 판단하기 어려웠습니다. 차량 목록만 보여주고 예약 가능 시간대나 충돌 정보가 없어 사용자가 여러 차량을 클릭해봐야 하는 불편함이 있었습니다. 또한 예약을 시도했다가 충돌이 발생하여 실패하는 경우가 많아 사용자 경험이 좋지 않았습니다.

### 원인 분석
- 예약 생성 화면에서 의사결정에 필요한 정보가 부족함
- 차량별 예약 현황 정보가 없음
- 예약 가능 시간대가 시각적으로 표시되지 않음
- 충돌 정보가 사전에 제공되지 않음

### 해결 과정

#### 1단계: 의사결정 정보 우선 설계
예약 생성 화면에서 다음 정보를 우선적으로 표시하도록 설계했습니다:
- 차량별 현재 예약 현황
- 예약 가능한 시간대 (시각적으로 표시)
- 예약 중인 차량의 다음 예약 시간
- 차량별 좌석 수 및 버퍼 시간

#### 2단계: 실시간 예약 가능 여부 표시
차량 목록에서 실시간으로 예약 가능 여부를 표시하도록 설계했습니다. 예약이 있는 시간대는 시각적으로 표시하여 사용자가 한눈에 파악할 수 있도록 했습니다.

#### 3단계: 충돌 사전 경고
예약 생성 시도 전에 충돌 가능성을 사전에 경고하도록 설계했습니다. 사용자가 시간을 선택하면 해당 시간대에 예약이 있는지 확인하고, 있다면 경고 메시지를 표시했습니다.

### 해결 결과
- 사용자가 한 화면에서 예약 가능 여부를 즉시 판단 가능
- 불필요한 클릭 및 페이지 이동 감소
- 예약 성공률 향상
- 사용자 만족도 향상

### 배운 점
- 사용자 경험을 고려한 UI 설계의 중요성
- 의사결정에 필요한 정보를 우선적으로 제공하는 것의 효과
- 사전 정보 제공이 사용자 만족도에 미치는 영향

## 4. 데이터베이스 레벨 충돌 방지 필요성

### 문제 상황
초기에는 애플리케이션 레벨에서만 예약 충돌을 검사했습니다. 그러나 동시에 여러 사용자가 같은 시간에 같은 차량을 예약하려고 할 때 Race Condition이 발생하여 중복 예약이 생성되는 문제가 발생했습니다.

### 원인 분석
- 애플리케이션 레벨에서만 충돌 검사를 하면 동시성 문제가 발생
- 트랜잭션 격리 수준만으로는 완전한 방지가 어려움
- 데이터베이스 레벨에서의 제약이 없음

### 해결 과정

#### 1단계: EXCLUDE USING GIST 제약 도입
PostgreSQL의 `EXCLUDE USING GIST` 제약을 활용하여 데이터베이스 레벨에서 중복 예약을 완전히 차단하도록 설계했습니다.

#### 2단계: 버퍼 시간 포함 종료 시간 자동 계산
차량별 버퍼 시간을 포함한 종료 시간(`end_with_buffer`)을 트리거로 자동 계산하도록 설계했습니다.

### 해결 결과
- 동시 요청 시에도 안전하게 충돌 방지
- 데이터 무결성 보장
- 애플리케이션 로직 단순화

### 배운 점
- 데이터베이스 제약을 활용한 데이터 무결성 보장의 중요성
- 애플리케이션 레벨과 데이터베이스 레벨의 이중 검증의 효과
- PostgreSQL의 고급 기능 활용의 필요성

